# ‡∏Å‡∏≤‡∏£‡∏´‡∏≤ Density Image ‡πÉ‡∏ô Point Cloud Rasterization

## ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°

**Density Image (‡∏†‡∏≤‡∏û‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô)** ‡∏Ñ‡∏∑‡∏≠ Channel ‡∏ó‡∏µ‡πà 0 ‡∏Ç‡∏≠‡∏á multi-channel grid ‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î (points) ‡∏ó‡∏µ‡πà‡∏ï‡∏Å‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û 2D

## ‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì

### 1. ‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á Grid
```
Point Cloud (3D)  ‚Üí  2D Grid (320√ó320 pixels)
- ‡∏Ç‡∏ô‡∏≤‡∏î pixel: 0.125 m/pixel
- ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°: 40√ó40 m (‚âà 1 ‡πÑ‡∏£‡πà)
```

### 2. ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î XYZ ‡πÄ‡∏õ‡πá‡∏ô Grid Index

```python
# ‡∏à‡∏≤‡∏Å pointcloud_rasterization.py (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ~147-153)

# ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ bounds
x_min, y_min = points[:, 0].min(), points[:, 1].min()
x_max, y_max = points[:, 0].max(), points[:, 1].max()

# ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î grid
width = int(np.ceil((x_max - x_min) / pixel_size))
height = int(np.ceil((y_max - y_min) / pixel_size))

# ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏£‡∏¥‡∏á (meters) ‡πÄ‡∏õ‡πá‡∏ô grid index (pixels)
x_idx = ((points[:, 0] - x_min) / pixel_size).astype(int)
y_idx = ((points[:, 1] - y_min) / pixel_size).astype(int)

# ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï grid
x_idx = np.clip(x_idx, 0, width - 1)
y_idx = np.clip(y_idx, 0, height - 1)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ NumPy Functions:**

#### `np.ceil()` - ‡∏õ‡∏±‡∏î‡πÄ‡∏•‡∏Ç‡∏Ç‡∏∂‡πâ‡∏ô
```python
np.ceil(3.2)  # = 4.0
np.ceil(3.8)  # = 4.0
np.ceil(-2.1) # = -2.0

# ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î:
width = int(np.ceil((50.7 - 0.0) / 0.125))
# = int(np.ceil(405.6))
# = int(406.0)
# = 406 pixels
```
**‡∏ó‡∏≥‡πÑ‡∏°‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ?** ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ grid ‡πÉ‡∏´‡∏ç‡πà‡∏û‡∏≠‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î (‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ floor ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ï‡∏Å‡∏´‡∏•‡πà‡∏ô)

#### `.astype(int)` - ‡πÅ‡∏õ‡∏•‡∏á‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
```python
arr = np.array([1.2, 3.7, 5.9])
arr.astype(int)  # = [1, 3, 5] (‡∏ï‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡∏ó‡∏¥‡πâ‡∏á)
```

#### `np.clip()` - ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á [min, max]
```python
# Syntax: np.clip(array, min_value, max_value)
np.clip([0, 5, 10, -3, 320], 0, 319)
# = [0, 5, 10, 0, 319]
#            ‚Üë     ‚Üë
#          ‡∏ï‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô 0  ‡∏ï‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô 319

# ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î: ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ index ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏≠‡∏ö grid
x_idx = np.clip([0, 5, 320, -1], 0, 319)
# = [0, 5, 319, 0]  ‚Üê ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà index out of bounds!
```
**‡∏ó‡∏≥‡πÑ‡∏°‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ?** ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô error ‡πÄ‡∏ß‡∏•‡∏≤ access array ‡∏ô‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```
Point ‡∏ó‡∏µ‡πà‡∏û‡∏¥‡∏Å‡∏±‡∏î (X=10.0, Y=20.0, Z=5.0)
- x_min = 0, pixel_size = 0.125
- x_idx = (10.0 - 0) / 0.125 = 80
- y_idx = (20.0 - 0) / 0.125 = 160
‚Üí Point ‡∏ô‡∏µ‡πâ‡∏ï‡∏Å‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô pixel (row=160, col=80)
```

### 3. ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Linear Index

```python
# ‡∏™‡∏£‡πâ‡∏≤‡∏á index ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 2D grid (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ~156)
linear_idx = y_idx * width + x_idx
```

**‡∏ó‡∏≥‡πÑ‡∏°‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ linear index?**
- ‡πÅ‡∏õ‡∏•‡∏á 2D coordinate (row, col) ‡πÄ‡∏õ‡πá‡∏ô 1D index
- ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ `np.bincount()`
- Formula: `index = row * width + col`

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```
Grid ‡∏Ç‡∏ô‡∏≤‡∏î 320√ó320
Point ‡∏ó‡∏µ‡πà (row=160, col=80)
‚Üí linear_idx = 160 * 320 + 80 = 51,280
```

### 4. ‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏î‡πâ‡∏ß‡∏¢ bincount (CORE!)

```python
# ‡∏à‡∏≤‡∏Å pointcloud_rasterization.py (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ~165-167)

# ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel (OPTIMIZED!)
flat_density = np.bincount(linear_idx, minlength=height*width)
channels[:, :, 0] = flat_density.reshape(height, width)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ NumPy Functions:**

#### `np.bincount()` - ‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô array
```python
# Syntax: np.bincount(x, weights=None, minlength=0)

# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô:
arr = np.array([0, 1, 1, 2, 2, 2])
count = np.bincount(arr)
# = [1, 2, 3]
#    ‚Üë  ‚Üë  ‚Üë
#   0  1  2  ‚Üê index (‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô arr)
#   ‡πÄ‡∏à‡∏≠ 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á, 2 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á, 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á

# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ö minlength:
arr = np.array([0, 2])
np.bincount(arr, minlength=5)
# = [1, 0, 1, 0, 0]  ‚Üê ‡∏¢‡∏≤‡∏ß 5 ‡∏ä‡πà‡∏≠‡∏á (‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏î‡πâ‡∏ß‡∏¢ minlength)
```

**‡∏ó‡∏≥‡πÑ‡∏°‡πÄ‡∏£‡πá‡∏ß?** ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏õ‡πá‡∏ô C implementation ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Python loop!

#### `np.reshape()` - ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á array
```python
# Syntax: array.reshape(new_shape)

# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:
arr_1d = np.array([1, 2, 3, 4, 5, 6])
arr_2d = arr_1d.reshape(2, 3)
# = [[1, 2, 3],
#    [4, 5, 6]]

arr_2d = arr_1d.reshape(3, 2)
# = [[1, 2],
#    [3, 4],
#    [5, 6]]

# ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î:
flat_density.reshape(height, width)
# ‡∏à‡∏≤‡∏Å [height*width] ‚Üí [height, width]
# ‡∏à‡∏≤‡∏Å [102400] ‚Üí [320, 320]
```

**‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á `np.bincount()`:**

1. **Input**: `linear_idx` = array ‡∏Ç‡∏≠‡∏á index ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏ï‡∏Å‡∏≠‡∏¢‡∏π‡πà
   ```
   ‡πÄ‡∏ä‡πà‡∏ô linear_idx = [100, 100, 100, 200, 200, 350, ...]
   ```

2. **Process**: ‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ index
   ```
   bincount([100, 100, 100, 200, 200, 350])
   = [0, 0, ..., 3, 0, ..., 2, 0, ..., 1, ...]
     ‚Üë          ‚Üë          ‚Üë          ‚Üë
   idx 0    idx 100   idx 200   idx 350
   ```

3. **Output**: Array ‡∏ó‡∏µ‡πà index i ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠ index i
   ```
   flat_density[100] = 3  (‡∏°‡∏µ 3 ‡∏à‡∏∏‡∏î‡∏ï‡∏Å‡πÉ‡∏ô pixel ‡∏ô‡∏µ‡πâ)
   flat_density[200] = 2  (‡∏°‡∏µ 2 ‡∏à‡∏∏‡∏î‡∏ï‡∏Å‡πÉ‡∏ô pixel ‡∏ô‡∏µ‡πâ)
   flat_density[350] = 1  (‡∏°‡∏µ 1 ‡∏à‡∏∏‡∏î‡∏ï‡∏Å‡πÉ‡∏ô pixel ‡∏ô‡∏µ‡πâ)
   ```

4. **Reshape**: ‡πÅ‡∏õ‡∏•‡∏á 1D array ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô 2D grid
   ```python
   flat_density.reshape(height, width)
   # ‡∏à‡∏≤‡∏Å [height*width] ‚Üí [height, width]
   ```

### 5. ‡∏Å‡∏≤‡∏£ Normalize (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)

```python
# ‡∏à‡∏≤‡∏Å pointcloud_rasterization.py (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ~196-201)

if normalize:
    for c in range(num_channels):
        channel = channels[:, :, c]
        if channel.max() > 0:
            # Scale ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡πà‡∏ß‡∏á [0, 1]
            channels[:, :, c] = (channel - channel.min()) / (channel.max() - channel.min())
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ NumPy Functions:**

#### `.min()` ‡πÅ‡∏•‡∏∞ `.max()` - ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î/‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
```python
arr = np.array([3, 7, 1, 9, 2])

arr.min()  # = 1 (‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î)
arr.max()  # = 9 (‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î)

# ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö axis:
arr_2d = np.array([[1, 5, 3],
                   [2, 8, 1]])

arr_2d.min()         # = 1 (‡∏ó‡∏±‡πâ‡∏á array)
arr_2d.min(axis=0)   # = [1, 5, 1] (‡πÅ‡∏ï‡πà‡∏•‡∏∞ column)
arr_2d.min(axis=1)   # = [1, 1] (‡πÅ‡∏ï‡πà‡∏•‡∏∞ row)
```

**Min-Max Normalization ‡∏™‡∏π‡∏ï‡∏£:**
```
normalized = (value - min) / (max - min)

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: [10, 50, 100]
min = 10, max = 100

(10 - 10) / (100 - 10) = 0/90 = 0.00
(50 - 10) / (100 - 10) = 40/90 = 0.44
(100 - 10) / (100 - 10) = 90/90 = 1.00

‚Üí [0.00, 0.44, 1.00]
```

**‡∏Å‡πà‡∏≠‡∏ô normalize:**
```
density = [0, 5, 10, 15, ..., 100]  (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏£‡∏¥‡∏á)
```

**‡∏´‡∏•‡∏±‡∏á normalize:**
```
density = [0.00, 0.05, 0.10, 0.15, ..., 1.00]  (scale ‡πÄ‡∏õ‡πá‡∏ô 0-1)
```

### 6. ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û PNG

```python
# ‡∏à‡∏≤‡∏Å pointcloud_rasterization.py (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ~224-234)

for c, name in enumerate(channel_names):
    channel = multi_channel_grid[:, :, c]
    
    # Normalize ‡πÄ‡∏õ‡πá‡∏ô 0-255 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û
    if channel.max() > channel.min():
        channel_normalized = ((channel - channel.min()) / 
                            (channel.max() - channel.min()) * 255).astype(np.uint8)
    else:
        channel_normalized = np.zeros_like(channel, dtype=np.uint8)
    
    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô .png
    img_path = os.path.join(channel_dir, f"{name}.png")
    cv2.imwrite(img_path, channel_normalized)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ NumPy Functions:**

#### `np.zeros_like()` - ‡∏™‡∏£‡πâ‡∏≤‡∏á array ‡πÄ‡∏ï‡πá‡∏°‡∏î‡πâ‡∏ß‡∏¢ 0 ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö array ‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
```python
# Syntax: np.zeros_like(array, dtype=None)

original = np.array([[1, 2, 3],
                     [4, 5, 6]])

zeros = np.zeros_like(original)
# = [[0, 0, 0],
#    [0, 0, 0]]  ‚Üê ‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô original

# ‡∏Å‡∏≥‡∏´‡∏ô‡∏î dtype:
zeros_uint8 = np.zeros_like(original, dtype=np.uint8)
# = [[0, 0, 0],
#    [0, 0, 0]]  ‚Üê ‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡πá‡∏ô uint8 (0-255)
```

**‡∏ó‡∏≥‡πÑ‡∏°‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ?** ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà channel ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÄ‡∏ä‡πà‡∏ô ‡∏ó‡∏∏‡∏Å pixel = 0) ‡∏à‡∏∞‡∏´‡∏≤‡∏£ 0/0 ‡πÑ‡∏î‡πâ NaN ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÉ‡∏ä‡πâ zeros_like ‡πÅ‡∏ó‡∏ô

#### `np.uint8` - ‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏¥‡∏î‡∏•‡∏ö 8-bit (0-255)
```python
# ‡∏†‡∏≤‡∏û PNG ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ 0-255 ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
arr_float = np.array([0.0, 0.5, 1.0])
arr_uint8 = (arr_float * 255).astype(np.uint8)
# = [0, 127, 255]

# ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà convert ‡∏à‡∏∞‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:
np.array([300]).astype(np.uint8)  # = [44] ‚Üê overflow!
np.array([-5]).astype(np.uint8)   # = [251] ‚Üê wraparound!
```

**‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤:**
```
Normalized [0.0, 0.3, 0.6, 1.0]
    ‚Üì √ó 255
PNG values [0, 76, 153, 255]
```

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

### Input: Point Cloud
```
Point 1: (X=10.0, Y=20.0, Z=5.0)
Point 2: (X=10.1, Y=20.0, Z=5.5)
Point 3: (X=10.0, Y=20.1, Z=4.8)
Point 4: (X=15.0, Y=25.0, Z=6.0)
...
‡∏£‡∏ß‡∏° 1,000,000 ‡∏à‡∏∏‡∏î
```

### Process:
```
1. ‡πÅ‡∏ö‡πà‡∏á grid 320√ó320 pixels
2. ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô index:
   - Point 1 ‚Üí pixel (160, 80)
   - Point 2 ‚Üí pixel (160, 80)  ‚Üê ‡∏ï‡∏Å‡πÉ‡∏ô pixel ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô!
   - Point 3 ‚Üí pixel (161, 80)
   - Point 4 ‚Üí pixel (200, 120)

3. ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏î‡πâ‡∏ß‡∏¢ bincount:
   - pixel (160, 80): 2 ‡∏à‡∏∏‡∏î
   - pixel (161, 80): 1 ‡∏à‡∏∏‡∏î
   - pixel (200, 120): 1 ‡∏à‡∏∏‡∏î
   - pixel ‡∏≠‡∏∑‡πà‡∏ô‡πÜ: 0 ‡∏à‡∏∏‡∏î

4. ‡∏™‡∏£‡πâ‡∏≤‡∏á density grid 320√ó320:
   grid[160, 80] = 2
   grid[161, 80] = 1
   grid[200, 120] = 1
   grid[...] = 0

5. Normalize (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£):
   max_density = 50 (pixel ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
   grid_normalized[160, 80] = 2/50 = 0.04
   grid_normalized[161, 80] = 1/50 = 0.02

6. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û:
   density.png (grayscale 0-255)
```

### Output: Density Image
```
output/rasterization_result/
‚îî‚îÄ‚îÄ scans_test_optimized_1m_raster_channels/
    ‚îî‚îÄ‚îÄ density.png  ‚Üê ‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ!
```

## ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏ú‡∏•‡∏†‡∏≤‡∏û Density

### ‡∏™‡∏µ‡πÉ‡∏ô‡∏†‡∏≤‡∏û
- **‡∏™‡∏µ‡∏î‡∏≥ (0)**: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡πÄ‡∏•‡∏¢ (empty)
- **‡∏™‡∏µ‡πÄ‡∏ó‡∏≤ (50-150)**: ‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
- **‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß (255)**: ‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏°‡∏≤‡∏Å (dense)

### ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
1. **‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏µ‡πÄ‡∏Ç‡πâ‡∏°**: ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô
2. **‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏µ‡∏™‡∏ß‡πà‡∏≤‡∏á**: 
   - ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏°‡∏µ point cloud ‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô
   - ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ overlap ‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≠‡∏ö
3. **‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏ä‡∏±‡∏î**: ‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏≠‡∏¢‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà

## ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏Ç‡∏≠‡∏á Density Channel

### 1. ‡πÅ‡∏¢‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
```python
# ‡∏´‡∏≤ threshold
density_threshold = 0.1

# ‡πÅ‡∏¢‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
has_data = density_channel > density_threshold
empty_area = density_channel <= density_threshold
```

### 2. ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ (‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö channel ‡∏≠‡∏∑‡πà‡∏ô)
```python
# ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏°‡∏±‡∏Å‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏™‡∏π‡∏á + ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏™‡∏π‡∏á
tree_candidates = (density > 0.5) & (z_max > 3.0) & (hag_mean > 2.0)
```

### 3. ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô
```python
# ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
low_quality = density < 0.2
print(f"Low quality area: {low_quality.sum() / density.size * 100:.1f}%")
```

### 4. ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô Input ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö YOLO
```python
# Multi-channel input ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö CNN
input_tensor = np.stack([
    density,      # Channel 0: ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô
    z_mean,       # Channel 1: ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
    hag_mean      # Channel 2: ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏û‡∏∑‡πâ‡∏ô
], axis=-1)  # Shape: (320, 320, 3)
```

## NumPy Functions Reference (‡∏™‡∏£‡∏∏‡∏õ)

### ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Array Structure

#### `np.vstack()` - Stack arrays ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á (vertical)
```python
# ‡∏à‡∏≤‡∏Å load_pointcloud: ‡∏£‡∏ß‡∏° X, Y, Z ‡πÄ‡∏õ‡πá‡∏ô Nx3
x = np.array([1, 2, 3])
y = np.array([4, 5, 6])
z = np.array([7, 8, 9])

points = np.vstack((x, y, z)).T
# ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:
# 1. vstack: [[1, 2, 3],    ‚Üê x
#             [4, 5, 6],    ‚Üê y
#             [7, 8, 9]]    ‚Üê z
#
# 2. .T (transpose): [[1, 4, 7],  ‚Üê point 1
#                     [2, 5, 8],  ‚Üê point 2
#                     [3, 6, 9]]  ‚Üê point 3
```

#### `np.zeros()` - ‡∏™‡∏£‡πâ‡∏≤‡∏á array ‡πÄ‡∏ï‡πá‡∏°‡∏î‡πâ‡∏ß‡∏¢ 0
```python
np.zeros((3, 4))
# = [[0, 0, 0, 0],
#    [0, 0, 0, 0],
#    [0, 0, 0, 0]]

np.zeros((320, 320, 6), dtype=np.float32)
# = array ‡∏Ç‡∏ô‡∏≤‡∏î 320√ó320√ó6 ‡∏ó‡∏∏‡∏Å‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô 0.0
```

#### `np.arange()` - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏•‡∏Ç
```python
np.arange(5)       # = [0, 1, 2, 3, 4]
np.arange(2, 7)    # = [2, 3, 4, 5, 6]
np.arange(0, 10, 2) # = [0, 2, 4, 6, 8] (step=2)
```

### ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡πÄ‡∏®‡∏©

#### `np.nan_to_num()` - ‡πÅ‡∏õ‡∏•‡∏á NaN/Inf ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏•‡∏Ç‡∏õ‡∏Å‡∏ï‡∏¥
```python
arr = np.array([1.0, np.nan, np.inf, -np.inf, 5.0])
np.nan_to_num(arr)
# = [1.0, 0.0, 1.79e+308, -1.79e+308, 5.0]
#         ‚Üë    ‚Üë          ‚Üë
#       NaN‚Üí0  Inf‚Üílarge  -Inf‚Üílarge negative

# ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î: ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô error ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏£ 0/0
np.nan_to_num(arr, 0)  # ‡πÅ‡∏ó‡∏ô NaN/Inf ‡∏î‡πâ‡∏ß‡∏¢ 0
```

#### `np.errstate()` - ‡∏õ‡∏¥‡∏î warning ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
```python
# ‡∏Å‡∏£‡∏ì‡∏µ‡∏õ‡∏Å‡∏ï‡∏¥: ‡∏´‡∏≤‡∏£ 0 ‡∏à‡∏∞‡∏°‡∏µ warning
a = np.array([1, 0])
b = 1 / a  # RuntimeWarning: divide by zero

# ‡πÉ‡∏ä‡πâ errstate ‡∏õ‡∏¥‡∏î warning:
with np.errstate(divide='ignore', invalid='ignore'):
    b = 1 / a  # ‡πÑ‡∏°‡πà‡∏°‡∏µ warning
# = [1., inf]
```

### ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Index

#### `np.where()` - ‡∏´‡∏≤ index ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
```python
arr = np.array([1, 5, 3, 8, 2])
indices = np.where(arr > 3)
# = (array([1, 3]),)  ‚Üê index 1 ‡πÅ‡∏•‡∏∞ 3 ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ > 3

# ‡πÉ‡∏ä‡πâ 2D:
arr_2d = np.array([[1, 5],
                   [3, 8]])
y, x = np.where(arr_2d > 3)
# y = [0, 1]  ‚Üê row indices
# x = [1, 1]  ‚Üê col indices
# ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á: (0,1)=5 ‡πÅ‡∏•‡∏∞ (1,1)=8
```

### SciPy Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ

#### `ndimage.maximum()` / `ndimage.minimum()` - ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ max/min ‡πÅ‡∏ö‡∏ö grouped
```python
from scipy import ndimage

values = np.array([5, 10, 3, 8, 2, 7])
indices = np.array([0, 0, 1, 1, 2, 2])

# ‡∏´‡∏≤ max ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°:
max_vals = ndimage.maximum(values, indices, index=[0, 1, 2])
# = [10, 8, 7]
#    ‚Üë   ‚Üë  ‚Üë
#  group 0: max(5,10)=10
#  group 1: max(3,8)=8
#  group 2: max(2,7)=7
```

**‡πÉ‡∏ä‡πâ‡πÉ‡∏ô rasterization:**
```python
# ‡∏´‡∏≤ z_max ‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel
z_max = ndimage.maximum(z_values, linear_idx, 
                        index=np.arange(height*width))
```

## Optimization ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç

### ‡πÄ‡∏î‡∏¥‡∏° (Slow):
```python
# Loop ‡∏ó‡∏∏‡∏Å pixel - ‡∏ä‡πâ‡∏≤‡∏°‡∏≤‡∏Å!
for i in range(height):
    for j in range(width):
        mask = (y_idx == i) & (x_idx == j)
        density[i, j] = mask.sum()  # ‡∏ô‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ï‡∏Å pixel ‡∏ô‡∏µ‡πâ
```
**‡πÄ‡∏ß‡∏•‡∏≤**: ~30-60 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 1M points

### ‡πÉ‡∏´‡∏°‡πà (Fast):
```python
# Vectorized - ‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å!
flat_density = np.bincount(linear_idx, minlength=height*width)
density = flat_density.reshape(height, width)
```
**‡πÄ‡∏ß‡∏•‡∏≤**: ~0.5-1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 1M points

**‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô 30-60 ‡πÄ‡∏ó‡πà‡∏≤!** üöÄ

## ‡∏™‡∏£‡∏∏‡∏õ

**Density Image** = ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel ‡∏Ç‡∏≠‡∏á 2D grid

**‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏Å:**
1. ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î 3D ‚Üí 2D grid indices
2. ‡πÉ‡∏ä‡πâ `np.bincount()` ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel (vectorized!)
3. Reshape ‡πÄ‡∏õ‡πá‡∏ô 2D array
4. Normalize ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û

**‡πÑ‡∏ü‡∏•‡πå Output:**
- `output/rasterization_result/.../density.png` - ‡∏†‡∏≤‡∏û grayscale
- `output/rasterization_result/..._raster.npy` - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö raw (multi-channel)

**‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
- ‡πÅ‡∏¢‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á/‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
- ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô
- Input ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Machine Learning (YOLO)

---

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

### ‡∏î‡∏π‡∏†‡∏≤‡∏û Density
```bash
# ‡∏ö‡∏ô Mac/Linux
open output/rasterization_result/scans_test_optimized_1m_raster_channels/density.png
```

### Load ‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå
```python
import numpy as np
import matplotlib.pyplot as plt

# Load multi-channel data
data = np.load('output/rasterization_result/scans_test_optimized_1m_raster.npy')
density = data[:, :, 0]  # Channel 0 = density

# ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
print(f"Min density: {density.min()}")
print(f"Max density: {density.max()}")
print(f"Mean density: {density.mean():.2f}")
print(f"Pixels with data: {(density > 0).sum():,}")

# Plot histogram
plt.hist(density[density > 0].flatten(), bins=50)
plt.xlabel('Density (normalized)')
plt.ylabel('Frequency')
plt.title('Density Distribution')
plt.show()
```

## ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢

**Q: ‡∏ó‡∏≥‡πÑ‡∏°‡∏ö‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏î‡∏≥?**  
A: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î point cloud ‡∏ï‡∏Å‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πâ‡∏ô (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πÅ‡∏Å‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï)

**Q: Normalize ‡∏Å‡∏±‡∏ö‡πÑ‡∏°‡πà Normalize ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?**  
A: 
- ‡πÑ‡∏°‡πà normalize: ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏£‡∏¥‡∏á (0, 5, 10, ..., 100)
- Normalize: scale ‡πÄ‡∏õ‡πá‡∏ô 0-1 (0.0, 0.05, 0.10, ..., 1.0)

**Q: bincount ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏´‡∏ô?**  
A: ‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å! ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 1M points ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏Ñ‡πà ~0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö loop ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ 30+ ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)

**Q: ‡πÉ‡∏ä‡πâ Density ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏≠‡πÑ‡∏´‡∏°?**  
A: ‡πÑ‡∏°‡πà‡∏û‡∏≠ ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö channel ‡∏≠‡∏∑‡πà‡∏ô ‡πÄ‡∏ä‡πà‡∏ô z_max, hag_mean ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏î‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
